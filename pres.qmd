---
title: "Computational Methods in Epidemic Simulation and Inference"
subtitle: "Not-So-Great Models in Complex Situations"
author: David Wu
date: 17 August 2023
institute: Monash University NUMBATS Seminar
format: 
    revealjs:
        theme: [simple, style.scss]
        slide-number: true
        show-slide-number: all
        html-math-method: mathjax
        include-in-header: mathjax1.html
        mermaid:
            theme: default
---

## Overview

- About Me
- Fitting ODE models
- COVID-19 and the Big Network Model
- Cheating with Surrogates

## About Me

<!-- 
::: {layout-ncol=3 .v-center-container .incremental .center}
![](img/python.jpeg){ #vcenter }

::: {.fragment}
![](img/uoa-v-colour2.png){ #vcenter }
:::

::: {.fragment}
[![](img/virus.jpg){ #vcenter }](https://www.sysmex-europe.com/fileadmin/_processed_/f/c/csm_Infection_disease_8f4b6cfecd.jpg)
:::

::: -->


# Section 1: Fitting ODE Models

## Mechanistic Models for Infectious Diseases

We have some idea of how infectious diseases spread.

We can write (approximations of) them down mathematically.

A nice way is with ordinary differential equations:

![](img/sir_diagram.png)

## Mechanistic Models for Infectious Diseases

We have some idea of how infectious diseases spread.

We can write (approximations of) them down mathematically.

A nice way is with ordinary differential equations:

$$\begin{gathered}
S_t = -\beta \frac{SI}{N}\\
I_t = \beta \frac{SI}{N} - \gamma I\\
R_t = \gamma I
\end{gathered}
$$


## Solving ODE Models {.smaller}

In general, we can write down a system of ODEs for the state $\vec{x}$ of the system with respect to some model parameters $\vec{\theta}$.

$$\vec{x}_t = \underbracket{f\left(\vec{x}, \vec{\theta}\right)}_{RHS}$$

. . . 

And we typically have to numerically integrate these systems in order to recover the state $\vec{x}$.

e.g. Euler's method
$$\vec{x}(t + \delta t) = \vec{x}(t) + f\left(\vec{x}(t), \vec{\theta}\right) \cdot \delta t$$

## Fitting ODEs: Objective and Setup

We typically have the setup:

$$\begin{gathered}
\overbracket{y}^{\mathclap{\text{data}}} = \overbracket{g(x)}^{\mathclap{\substack{\text{observation}\\\text{process}}}} + \overbracket{\,\mathsf{\varepsilon}\,}^{\mathclap{\text{error}}}\\
x_t = f(x, \theta)
\end{gathered}$$

. . .

Typically we want to do two things:

::: {.incremental}
1. Predict $x(t)$ or $y(t)$ into the future, and
2. Understand underlying mechanisms, as abstracted by model parameters $\theta$.
:::



## Problems

::: {.incremental}

(@) Numerical integration can be expensive.



(@) Our model can be inadequate.

:::

## Generalised Profiling


## UQ: Profile Likelihood and Bootstrapping


## Case Study: Measles in Samoa 2019



## 


# Section 2: COVID-19 and the Big Network Model

## Motivation(s)

ODE models aren't great for capturing complex processes and populations.

We want to be able to simulate more detailed, stochastic models of the spread of infection in order to understand potential government policies

## The Network



## Problems

The network is _big_. We have ~5 million individuals, and ~10 million contexts in which they can spread.

Simulating this number of agents is relatively expensive.

Also, many processes are non-Markovian.

## Existing Approaches

Gillespie (direct method) for (multiple) Markovian processes.



# Section 3: Cheating with Surrogates

## Sales Pitch

Complex models are expensive to simulate, and thus expesive to infer.

Simple models are bad at capturing all the mechanisms.

We can get the <span style="color:#a161d9">b</span><span style="color:#F0DA16">e</span><span style="color:#a161d9">s</span><span style="color:#F0DA16">t </span><span style="color:#a161d9">o</span><span style="color:#F0DA16">f </span><span style="color:#a161d9">b</span><span style="color:#F0DA16">o</span><span style="color:#a161d9">t</span><span style="color:#F0DA16">h </span><span style="color:#a161d9">w</span><span style="color:#F0DA16">o</span><span style="color:#a161d9">r</span><span style="color:#F0DA16">l</span><span style="color:#a161d9">d</span><span style="color:#F0DA16">s</span> by using the simple model as a surrogate for the more complex model, and correcting the difference.

## How

Complex model: 
$$x(t) = \zeta(t; \theta, \eta)$$

Simple model: $$x(t) = s(t; \theta)$$

Correction term: $$C(t; \theta, \eta) = \zeta(t; \theta, \eta) - s(t;\theta)$$

too hard

## How
Complex model: 
$$x(t) = \zeta(t; \theta, \eta)$$

Simple model: $$x(t) = s(t; \theta)$$

# The Bit Where You Clock Back In

## Takeaways



## Thanks



## Questions? {.standout}



